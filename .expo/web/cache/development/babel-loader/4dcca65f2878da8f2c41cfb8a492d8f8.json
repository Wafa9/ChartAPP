{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport XDate from 'xdate';\nimport constants from \"../commons/constants\";\nexport var HOUR_BLOCK_HEIGHT = 100;\nvar OVERLAP_EVENTS_SPACINGS = 10;\n\nfunction buildEvent(event, left, width, _ref) {\n  var _ref$dayStart = _ref.dayStart,\n      dayStart = _ref$dayStart === void 0 ? 0 : _ref$dayStart,\n      _ref$hourBlockHeight = _ref.hourBlockHeight,\n      hourBlockHeight = _ref$hourBlockHeight === void 0 ? HOUR_BLOCK_HEIGHT : _ref$hourBlockHeight;\n  var startTime = new XDate(event.start);\n  var endTime = event.end ? new XDate(event.end) : new XDate(startTime).addHours(1);\n  var dayStartTime = new XDate(startTime).clearTime();\n  return _objectSpread(_objectSpread({}, event), {}, {\n    top: (dayStartTime.diffHours(startTime) - dayStart) * hourBlockHeight,\n    height: startTime.diffHours(endTime) * hourBlockHeight,\n    width: width,\n    left: left\n  });\n}\n\nfunction hasCollision(a, b) {\n  return a.end > b.start && a.start < b.end;\n}\n\nfunction calcColumnSpan(event, columnIndex, columns) {\n  var colSpan = 1;\n\n  for (var i = columnIndex + 1; i < columns.length; i++) {\n    var column = columns[i];\n    var foundCollision = column.find(function (ev) {\n      return hasCollision(event, ev);\n    });\n\n    if (foundCollision) {\n      return colSpan;\n    }\n\n    colSpan++;\n  }\n\n  return colSpan;\n}\n\nfunction packOverlappingEventGroup(columns, calculatedEvents, populateOptions) {\n  var _populateOptions$scre = populateOptions.screenWidth,\n      screenWidth = _populateOptions$scre === void 0 ? constants.screenWidth : _populateOptions$scre,\n      _populateOptions$over = populateOptions.overlapEventsSpacing,\n      overlapEventsSpacing = _populateOptions$over === void 0 ? OVERLAP_EVENTS_SPACINGS : _populateOptions$over;\n  columns.forEach(function (column, columnIndex) {\n    column.forEach(function (event) {\n      var columnSpan = calcColumnSpan(event, columnIndex, columns);\n      var eventLeft = columnIndex / columns.length * screenWidth;\n      var eventWidth = screenWidth * (columnSpan / columns.length);\n\n      if (columnIndex + columnSpan <= columns.length - 1) {\n        eventWidth -= overlapEventsSpacing;\n      }\n\n      calculatedEvents.push(buildEvent(event, eventLeft, eventWidth, populateOptions));\n    });\n  });\n}\n\nfunction populateEvents(_events, populateOptions) {\n  var lastEnd = null;\n  var columns = [];\n  var calculatedEvents = [];\n\n  var events = _events.map(function (ev, index) {\n    return _objectSpread(_objectSpread({}, ev), {}, {\n      index: index\n    });\n  }).sort(function (a, b) {\n    if (a.start < b.start) return -1;\n    if (a.start > b.start) return 1;\n    if (a.end < b.end) return -1;\n    if (a.end > b.end) return 1;\n    return 0;\n  });\n\n  events.forEach(function (ev) {\n    if (lastEnd !== null && ev.start >= lastEnd) {\n      packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n      columns = [];\n      lastEnd = null;\n    }\n\n    var placed = false;\n\n    for (var i = 0; i < columns.length; i++) {\n      var col = columns[i];\n\n      if (!hasCollision(col[col.length - 1], ev)) {\n        col.push(ev);\n        placed = true;\n        break;\n      }\n    }\n\n    if (!placed) {\n      columns.push([ev]);\n    }\n\n    if (lastEnd === null || ev.end > lastEnd) {\n      lastEnd = ev.end;\n    }\n  });\n\n  if (columns.length > 0) {\n    packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n  }\n\n  return calculatedEvents;\n}\n\nexport default populateEvents;","map":{"version":3,"sources":["/home/lamaaldohayan/Desktop/project/financeApp/node_modules/react-native-calendars/src/timeline/Packer.js"],"names":["XDate","constants","HOUR_BLOCK_HEIGHT","OVERLAP_EVENTS_SPACINGS","buildEvent","event","left","width","dayStart","hourBlockHeight","startTime","start","endTime","end","addHours","dayStartTime","clearTime","top","diffHours","height","hasCollision","a","b","calcColumnSpan","columnIndex","columns","colSpan","i","length","column","foundCollision","find","ev","packOverlappingEventGroup","calculatedEvents","populateOptions","screenWidth","overlapEventsSpacing","forEach","columnSpan","eventLeft","eventWidth","push","populateEvents","_events","lastEnd","events","map","index","sort","placed","col"],"mappings":"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","sourcesContent":["// @flow\nimport XDate from 'xdate';\nimport constants from '../commons/constants';\nexport const HOUR_BLOCK_HEIGHT = 100;\nconst OVERLAP_EVENTS_SPACINGS = 10;\nfunction buildEvent(event, left, width, { dayStart = 0, hourBlockHeight = HOUR_BLOCK_HEIGHT }) {\n    const startTime = new XDate(event.start);\n    const endTime = event.end ? new XDate(event.end) : new XDate(startTime).addHours(1);\n    const dayStartTime = new XDate(startTime).clearTime();\n    return {\n        ...event,\n        top: (dayStartTime.diffHours(startTime) - dayStart) * hourBlockHeight,\n        height: startTime.diffHours(endTime) * hourBlockHeight,\n        width,\n        left\n    };\n}\nfunction hasCollision(a, b) {\n    return a.end > b.start && a.start < b.end;\n}\nfunction calcColumnSpan(event, columnIndex, columns) {\n    let colSpan = 1;\n    for (let i = columnIndex + 1; i < columns.length; i++) {\n        const column = columns[i];\n        const foundCollision = column.find(ev => hasCollision(event, ev));\n        if (foundCollision) {\n            return colSpan;\n        }\n        colSpan++;\n    }\n    return colSpan;\n}\nfunction packOverlappingEventGroup(columns, calculatedEvents, populateOptions) {\n    const { screenWidth = constants.screenWidth, overlapEventsSpacing = OVERLAP_EVENTS_SPACINGS } = populateOptions;\n    columns.forEach((column, columnIndex) => {\n        column.forEach(event => {\n            const columnSpan = calcColumnSpan(event, columnIndex, columns);\n            const eventLeft = (columnIndex / columns.length) * screenWidth;\n            let eventWidth = screenWidth * (columnSpan / columns.length);\n            if (columnIndex + columnSpan <= columns.length - 1) {\n                eventWidth -= overlapEventsSpacing;\n            }\n            calculatedEvents.push(buildEvent(event, eventLeft, eventWidth, populateOptions));\n        });\n    });\n}\nfunction populateEvents(_events, populateOptions) {\n    let lastEnd = null;\n    let columns = [];\n    const calculatedEvents = [];\n    const events = _events\n        .map((ev, index) => ({ ...ev, index: index }))\n        .sort(function (a, b) {\n        if (a.start < b.start)\n            return -1;\n        if (a.start > b.start)\n            return 1;\n        if (a.end < b.end)\n            return -1;\n        if (a.end > b.end)\n            return 1;\n        return 0;\n    });\n    events.forEach(function (ev) {\n        // Reset recent overlapping event group and start a new one\n        if (lastEnd !== null && ev.start >= lastEnd) {\n            packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n            columns = [];\n            lastEnd = null;\n        }\n        // Place current event in the right column where it doesn't overlap\n        let placed = false;\n        for (let i = 0; i < columns.length; i++) {\n            const col = columns[i];\n            if (!hasCollision(col[col.length - 1], ev)) {\n                col.push(ev);\n                placed = true;\n                break;\n            }\n        }\n        // If curr event wasn't placed in any of the columns, create a new column for it\n        if (!placed) {\n            columns.push([ev]);\n        }\n        if (lastEnd === null || ev.end > lastEnd) {\n            lastEnd = ev.end;\n        }\n    });\n    if (columns.length > 0) {\n        packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n    }\n    return calculatedEvents;\n}\nexport default populateEvents;\n"]},"metadata":{},"sourceType":"module"}